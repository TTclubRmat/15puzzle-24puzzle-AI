# 15puzzle & 24puzzle AI

一个不断研究更新的解数字华容道算法(4×4和5×5甚至更高阶），基于曼哈顿路径、线性冲突、A*算法、束搜索，保证在无限的状态空间中找到更优解。由于最优解的搜索空间巨大，可能无法在有限时间和内存中给出。

众所周不知，我高中起开始玩扫雷联萌，接触了包括数字华容道在内的许多益智游戏。无止境的滑动与懒惰让我没有什么提升技术的兴趣，但结合那时我已经学的半透不透的Java，我生出了一个编写程序的念头：我是否能编写一个华容道程序得到最短路径的解呢？

## 最近更新

- 2025年1月9日：新增C动态链接库版本：hrdai_c_test_24puzzle.py，速度更快，达到C语言级别
- 2025年1月8日：算法代码第一次开源

## DFS与BFS的初尝浅试

### 深度优先搜索 (DFS)

解释DFS很简单：想象一下你在一个迷宫里寻找出口。深度优先搜索就像是你一直沿着一条路走到底，直到你找不到路可以继续前进为止。如果走到一个死胡同，你就回退一步，然后尝试另一条路。这样不断地探索下去，直到找到出口或者所有可能的路径都被尝试过。

**特点：**
- 一条路走到头
- 遇到死路时回头，尝试其他分支。
- 可能会找到解，但不一定是最佳解。

**遇到的问题：**
- 如果第一步错了，就会导致要把对应puzzle所有状态全部遍历一遍。15puzzle大约有 $$16! = 2.09 \times 10^{13}$$ 种（包含不可解情况，仅供参考）状态，其状态空间过于庞大。使用Java编写DFS时，计算机每秒的计算量大约在50000至100000，假设第一步走错，那么一次计算需要的时间为3～9年。如果你的DFS算法要存储搜索过的状态，同样假设第一步走错，忽略重复情况，一次计算需要的运行内存至少为 $$(16!*16)/2/4/1024^4=38.06TB$$

### 广度优先搜索 (BFS)

再想象一下你在同一个迷宫里，但这次你决定同时探索所有的可能性。广度优先搜索就像是你一层层地向外扩展，先探索离起点最近的所有位置，然后再探索下一层的位置，以此类推，直到找到出口。

**特点：**
- 一层一层地扩展搜索范围。
- 总是保证最先找到的解是最短路径。
- 需要额外的数据结构存储待探索的节点。

**遇到的问题：**
- 如果说DFS是有概率为15puzzle计算数年之久，那么BFS就是一定会计算到天长地久。它不适用于如此大规模问题。

## 启发式函数与A-star搜索

DFS和BFS我皆编写过算法代码，网上也有很多写成的8puzzle的DFS与BFS解法，在此不一一展示。在算法学习时，我逐渐接触到一个新的概念——启发式函数。

想象一下，你是4×4数字华容道中的空格，你知道你的前后左右走完之后离目标状态还有多少距离，于是你可以选出离目标状态距离最短的那步，然后继续选择离目标状态距离最短的那步，直到选出结果。这里离目标状态的距离称为启发式函数（也叫启发函数或估价函数），它主要用于指导搜索算法的方向，以更高效地找到问题的解决方案；而这样的搜索方法便是A-star搜索。

在解决数字华容道时，一个常用的启发式函数是曼哈顿距离，联萌软件里每局也会显示曼哈顿距离。它计算每个数字与其目标位置之间的水平和垂直距离之和，此结果越小代表离目标状态越近，是一个合理又精确的的估计距离的启发式函数，能保证通过启发函数找到的路径是最短路径。

### 关于A-star搜索算法实现的技术细节

A-star搜索算法使用一个评价函数 `f(n) = g(n) + h(n)`  来确定下一步的移动方向，其中：
- `g(n)`  是从初始状态到达当前节点n的实际代价；
- `h(n)`  是启发式函数，表示从当前节点n到达目标状态的预计代价；
- `f(n)`  是节点n的总估计代价。

在每一步中，A-star算法会选择 `f(n)`  最小的节点进行扩展。如此，算法不仅考虑了已知的实际代价 `g(n)` ，还考虑了启发式函数 `h(n)`  给出的预测代价，以指导搜索朝着更有可能接近目标的方向进行。

## 以牺牲o解为代价追求更快的计算速度

到此为止，如果你按照以上的逻辑编写出了A-star搜索算法，你已经能够成功使用A-star搜索算法计算出最短路径。在实际应用中，A-star搜索需要记录已遍历的节点、待遍历的最短路径，不经过优化和无限的遍历可能会消耗难以想象的内存。未经优化时，算法在128G内存的工作站上甚至出现了boom。使用栈和树可能是一个优化的好的方向。我在此使用了优先队列和堆数据结构来进行内存优化与速度优化。

为了追求更快的速度（例如在1秒内计算出任何4×4华容道的解），我们需要让程序优先计算我们想让它计算的内容。但是这样会牺牲最短路径。例如，我们将1、2、3、4、5、9、13这几个数的权重放大，使程序优先将阶归位。不过实际情况里并不是阶优先归位为最短路径，这个办法效果也不好。

于是我想到，如果让需要转角的数字额外增加步数，是否这样的距离更加准确呢？经过实际编写与调试，在52步最短路径以内的puzzle计算时将需要转角的步数乘以1.2，基本不会额外使结果路径变远，但在55步之后，可能会使路径结果额外增加3-7步。

线性冲突也是一个必要的因子，例如1、2、3、4的排列为顺序排列，而1、3、2、4的排列为线性冲突的排列。我又想到，线性冲突（行与列的顺序错误）时额外增加步数是否能让距离更加准确呢？答案是yes，经过不断测试，转角因子为1.2，线性冲突因子为7.0（即当发生一组线性冲突就额外使到终点距离增加7步）时，速度最快，在52步以内也非常精确。同样的，在55步之后，可能会使路径额外增加3-7步。

## 结语

该算法从高中毕业（2023年6月10日）就开始编写，一直到2024年8月10日才优化至此。由于扫雷联盟的大佬们想看算法的5×5的算法解法，我在5×5的算法优化上又引入了束搜索以限制搜索广度。当看到算法完美运行的那刻，一切苦累皆成美好。

## 未来

训练一个准确的神经网络模型能使包括99puzzle在内的的算法的速度和精确性达到人无法企及的程度，请静候下一刻的美好。
